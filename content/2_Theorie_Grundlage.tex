\chapter{Grundlagenkapitel}\label{ch:data}

\section{Geschichte von Go}
Eines der Kernprinzipien von GO ist die Einfachheit. Die Idee und das Konzept wurde aus einer Unzufriedenheit 2007 als Nebenprojekt von Rob Pike, Robert Griesemer, und Ken Thompson in der Firma Google herausgearbeitet. Zu der Zeit wurden mehrere der populären Sprachen wie C++, Java und Python verwendet. Aufgrund von langen Entwicklungshistorien wurde viel Komplexität in die Sprache eingeführt \cite{donovan_go_2016}. Besonders bei großen Projekten, bei denen viele Entwickler zusammenarbeiten müssen, kann dies problematische Maßstäbe annehmen. Ein Beispiel der Sprache C++ waren Dependencies. Diese wurden undurchsichtig und verursachten ein unabsichtliches Neuladen von Libraries. Dadurch wuchsen die Kompilierzeiten sowohl in Dauer als auch in Speicherbedarf. Deshalb soll GO unter allen Umständen einfach gehalten werden, auch wenn es dadurch zu langsameren und weniger effizienten Programmen führen kann. Zentral ist hier der Verzicht auf Features. Bereitgestellt wird nur das nötigste. Neue Features erfordern meist mehr Komplexität. Beispielsweise existieren keine Klassen und keine Vererbung. Die Entwickler sollen mit Structs und Interfaces auskommen.\cite{cox_go_2022}

Eng zusammenhängend mit der Einfachheit steht die Skalierbarkeit. Skalierbar sein sollen die Software an sich und die Möglichkeit, diese auf mehr Hardware laufen lassen zu können. Hier lag ein weiteres Problem der etablierten Sprachen. Diese Programmiersprachen wurden vor der aufkommenden Multicore Entwicklung konzipiert. Diese Entwicklung richtig ausnutzen zu können stellten Entwickler vor Herausforderungen denn sie erfordert paralleles Arbeiten. Die Art und Weise wie die existenten Programmiersprachen damit umgingen, reichte Google nicht aus. Ebenso soll der Entwicklungsaufwand gut skalierbar sein. Die Anzahl der Entwickler soll ansteigen können ohne das dies zu mehr Problemen führt. Als einer der größten Techfirmen zu der Zeit stellte Google mehrere tausend Mitarbeiter für die Softwareentwicklung an. Diese mussten an einer Code Basis effizient arbeiten können. Code zu Standardisieren für mehrere Entwickler wurde zu einer hohen Priorität und nahm so Einfluss auf die frühen Entwicklungsschritte. Essentiell für diese Koordinierung ist eine einfache Entwicklungsumgebung. Der Compiler nimmt Anpassungen automatisch und das Programm muss somit nicht von dem Entwickler selbst angepasst werden . Go ist aufgrund dieses Hintergrunds nicht nur bei Google die populäre Wahl für Cloud Infrastruktur. Auch andere Firmen wie Docker setzen auf die Sprache.

Weiterhin ist jedoch eine schnelle und effiziente Ausführung wichtig. Es wird versucht aus der Entwicklung älterer Sprachen die richtigen Schlüsse zu ziehen und deren Probleme zu vermeiden. Statt mit neuen und umfangreichen Ansätzen will Go mit Balance und Fokus auf das Entwicklungsumfeld überzeugen. Hierfür muss nicht die effizienteste Lösung gewählt werden \cite{pike_less_2012}. Die Einfachheit darf nicht darunter leiden.\cite{cox_go_2022}

Nach einer zweijährigen Entwicklungsphase wurde Go 2009 als Open Source Projekt veröffentlicht. \cite{meyerson_go_2014}
Seitdem gab es mehrere Meilensteine:

Charakteristische Merkmale: 
Ein Garbage Collector erhöht den Speicherbedarf und senkt die Geschwindigkeit. Dieser gestaltet Programme einfacher und wird deshalb in Go benutzt. Ersetzt werden kann Vererbung diese durch Interfaces, die dynamischer gestaltet werden können als in anderen Sprachen. 
Type System ist einfacher gehalten und hat dadurch aber auch weniger Möglichkeiten. Ist aber recht ausgeglichen mit genügend Komplexität aber trotzdem einfach \cite{donovan_go_2016}.
Viele Features sind ausgelassen(evtl aufzählen)

\subsection{Concurrency/Goroutines}
Jeder Thread oder jede Goroutine hat einen eigenen Stack. Dieser wird benutzt um die lokalen Variablen zu speichern. Typischerweise haben Threads eine festgesetzte Stack Größe. Goroutines hingegen legen diese dynamisch fest je nach Bedarf. So kann die Skalierbarkeit einfacher gestaltet werden. Diese Goroutinen starten klein und skalieren nur hoch bei jeweiligen Bedarf. 
GO verlässt sich nicht auf den System eigenen Scheduler. Dieser entscheidet welcher Thread als Nächstes ausgeführt wird. Goroutinen multiplexed mehrere Goroutinen in einen System Thread. Dadurch laufen mehrere Goroutinen auf einem Thread. Dies ermöglicht, zwischen den Goroutinen zu wechseln ohne den Thread Kontext ändern zu müssen. 
\subsection{Garbage Collector}
\subsection{static Typing}
\subsection{Fragen}

Was genau muss in dem Grundlagenkapitel behandelt werden? Die Geschichte und Philosophie habe ich bereits bearbeitet. Wieviel der technischen Aspekte sollen hier bereits angerissen werden? Sollen hier vielleicht die wichtigsten Unterschiede/ Merkmale schonmal angedeutet werden